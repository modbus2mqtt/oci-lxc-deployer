#!/bin/bash
# pvetest - CI test CLI for delegating test execution to a remote test-worker
#
# All infrastructure details come from environment variables,
# keeping CI workflows free of hostnames, IPs, and MAC addresses.
#
# Required environment variables:
#   PVETEST_HOST           Hostname/IP of the PVE backend server (for WOL, snapshots, nested VM)
#   PVETEST_WORKER_PORT    SSH port for the test-worker (default: 22)
#
# Optional environment variables:
#   PVETEST_WORKER_HOST    Hostname of the test-worker (default: same as PVETEST_HOST)
#                          When the test-worker is a native LXC on vmbr0 with DHCP,
#                          it is directly reachable by its hostname on the network.
#   PVETEST_WORKER_USER    SSH user (default: root)
#   PVETEST_WOL_MAC        MAC address for Wake-on-LAN
#   PVETEST_WOL_INTERFACE  Network interface for etherwake
#   PVETEST_DEPLOYER_PORT  Deployer API port for health check
#   PVETEST_WORKSPACE      Remote workspace path (default: /root/workspace)
#   PVETEST_WOL_TIMEOUT    Max seconds to wait for WOL wake (default: 180)
#   PVETEST_SSH_TIMEOUT    Max seconds to wait for SSH (default: 120)
#   PVETEST_API_TIMEOUT    Max seconds to wait for deployer API (default: 300)
#
# For install-test / snapshot commands (optional):
#   PVETEST_NESTED_SSH_PORT    SSH port for nested VM (via PVE host forwarding)
#   PVETEST_NESTED_VMID        VM ID of the nested Proxmox VM
#   PVETEST_SNAPSHOT_NAME      Snapshot name (default: baseline)
#   PVETEST_DEPLOYER_VMID      Deployer container VMID (default: 300)
#   PVETEST_DEPLOYER_BRIDGE    Network bridge (default: vmbr1)
#   PVETEST_DEPLOYER_STATIC_IP Static IP for deployer (default: 10.0.0.100/24)
#   PVETEST_DEPLOYER_GATEWAY   Gateway for deployer (default: 10.0.0.1)
#   PVETEST_OWNER              GitHub owner for install (default: modbus2mqtt)
#   PVETEST_OCI_OWNER          OCI image owner (default: modbus2mqtt)

set -euo pipefail

# Source environment file if present (deployed by oci-lxc-deployer)
ENV_FILE="/etc/oci-lxc-deployer/pvetest.env"
if [ -f "$ENV_FILE" ]; then
    set -a
    . "$ENV_FILE"
    set +a
fi

HOST="${PVETEST_HOST:?PVETEST_HOST is required}"
PORT="${PVETEST_WORKER_PORT:-22}"
WORKER_HOST="${PVETEST_WORKER_HOST:-$HOST}"
WORKER_USER="${PVETEST_WORKER_USER:-root}"
WOL_MAC="${PVETEST_WOL_MAC:-}"
WOL_IFACE="${PVETEST_WOL_INTERFACE:-}"
DEPLOYER_PORT="${PVETEST_DEPLOYER_PORT:-}"
WORKSPACE="${PVETEST_WORKSPACE:-/root/workspace}"
WOL_TIMEOUT="${PVETEST_WOL_TIMEOUT:-180}"
SSH_TIMEOUT="${PVETEST_SSH_TIMEOUT:-120}"
API_TIMEOUT="${PVETEST_API_TIMEOUT:-300}"

# Optional: nested VM config (for install-test / snapshot commands)
NESTED_PORT="${PVETEST_NESTED_SSH_PORT:-}"
NESTED_VMID="${PVETEST_NESTED_VMID:-}"

SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o BatchMode=yes -o ConnectTimeout=10 -o LogLevel=ERROR"

info()    { echo -e "\033[1;33m[pvetest]\033[0m $*"; }
ok()      { echo -e "\033[0;32m[pvetest]\033[0m $*"; }
fail()    { echo -e "\033[0;31m[pvetest]\033[0m $*" >&2; exit 1; }

# SSH to test-worker (WORKER_HOST may differ from HOST when test-worker is native LXC on DHCP)
remote_ssh() { ssh $SSH_OPTS -p "$PORT" "$WORKER_USER@$WORKER_HOST" "$@"; }
remote_scp() { scp $SSH_OPTS -P "$PORT" "$@"; }

# SSH to PVE host directly (port 22)
host_ssh() { ssh $SSH_OPTS "root@$HOST" "$@"; }
host_scp_to() { scp $SSH_OPTS "$@" "root@$HOST:/tmp/"; }

# SSH to nested VM via PVE host port forwarding
nested_ssh() {
    [ -z "$NESTED_PORT" ] && fail "PVETEST_NESTED_SSH_PORT is required for this command"
    ssh $SSH_OPTS -p "$NESTED_PORT" "root@$HOST" "$@"
}
nested_scp_to() {
    [ -z "$NESTED_PORT" ] && fail "PVETEST_NESTED_SSH_PORT is required for this command"
    local src="$1"
    local dst="${2:-/tmp/}"
    scp $SSH_OPTS -P "$NESTED_PORT" "$src" "root@$HOST:$dst"
}

# --- wake: WOL + wait for SSH + optional deployer API check ---
cmd_wake() {
    info "Checking if $HOST is reachable..."
    if ! ping -c 1 -W 3 "$HOST" &>/dev/null; then
        [ -z "$WOL_MAC" ] && fail "$HOST unreachable and PVETEST_WOL_MAC not set"

        info "Sending WOL packet to $WOL_MAC..."
        if [ -n "$WOL_IFACE" ]; then
            sudo etherwake -i "$WOL_IFACE" "$WOL_MAC" || fail "etherwake failed"
        else
            sudo etherwake "$WOL_MAC" 2>/dev/null || sudo etherwake -D "$WOL_MAC" || fail "etherwake failed"
        fi

        info "Waiting for $HOST to wake (max ${WOL_TIMEOUT}s)..."
        local i
        for i in $(seq 1 "$WOL_TIMEOUT"); do
            ping -c 1 -W 2 "$HOST" &>/dev/null && break
            [ $((i % 15)) -eq 0 ] && info "  still waiting... ${i}s"
            sleep 1
        done
        ping -c 1 -W 2 "$HOST" &>/dev/null || fail "$HOST did not wake within ${WOL_TIMEOUT}s"
    fi
    ok "$HOST is reachable"

    # Wait for test-worker SSH
    info "Waiting for test-worker SSH ($WORKER_HOST:$PORT, max ${SSH_TIMEOUT}s)..."
    local deadline=$((SSH_TIMEOUT / 2))
    local i
    for i in $(seq 1 "$deadline"); do
        remote_ssh "true" 2>/dev/null && break
        [ $((i % 10)) -eq 0 ] && info "  still waiting... $((i * 2))s"
        sleep 2
    done
    remote_ssh "true" 2>/dev/null || fail "SSH not ready after ${SSH_TIMEOUT}s"
    ok "Test-worker SSH is ready"

    # Optional: wait for deployer API
    if [ -n "$DEPLOYER_PORT" ]; then
        local url="http://${HOST}:${DEPLOYER_PORT}"
        info "Waiting for deployer API at $url (max ${API_TIMEOUT}s)..."
        local i
        for i in $(seq 1 "$API_TIMEOUT"); do
            curl -sf --connect-timeout 3 "$url/" 2>/dev/null | grep -q "doctype" && break
            [ $((i % 15)) -eq 0 ] && info "  still waiting... ${i}s"
            sleep 1
        done
        curl -sf --connect-timeout 3 "$url/" 2>/dev/null | grep -q "doctype" \
            || fail "Deployer API not ready after ${API_TIMEOUT}s"
        ok "Deployer API is healthy"
    fi
}

# --- checkout: clone/fetch/checkout a specific commit ---
cmd_checkout() {
    local sha="${1:?Usage: pvetest checkout <sha> <repo-url>}"
    local repo="${2:?Usage: pvetest checkout <sha> <repo-url>}"

    info "Checking out $sha on test-worker..."
    remote_ssh bash <<SCRIPT
set -e
if [ ! -d $WORKSPACE/.git ]; then
    # Remove non-git content (e.g. from rsync) before cloning
    rm -rf $WORKSPACE
    git clone "$repo" $WORKSPACE
fi
cd $WORKSPACE
git fetch origin
git checkout --force $sha
SCRIPT
    ok "Checkout $sha complete"
}

# --- exec: run a command on the test-worker in the workspace ---
cmd_exec() {
    [ $# -eq 0 ] && fail "Usage: pvetest exec <command...>"
    remote_ssh bash <<SCRIPT
set -e
export PVE_HOST="$HOST"
cd $WORKSPACE
$*
SCRIPT
}

# --- fetch: copy files from test-worker to local ---
cmd_fetch() {
    local src="${1:?Usage: pvetest fetch <remote-path> <local-path>}"
    local dst="${2:-.}"
    mkdir -p "$dst"
    info "Fetching $src from test-worker..."
    remote_scp -r "$WORKER_USER@$WORKER_HOST:$WORKSPACE/$src" "$dst"
    ok "Fetched $src -> $dst"
}

# --- host-exec: run a command on the PVE host (port 22) ---
cmd_host_exec() {
    [ $# -eq 0 ] && fail "Usage: pvetest host-exec <command...>"
    host_ssh "$*"
}

# --- nested-exec: run a command on the nested VM ---
cmd_nested_exec() {
    [ $# -eq 0 ] && fail "Usage: pvetest nested-exec <command...>"
    nested_ssh "$*"
}

# --- snapshot-rollback: rollback nested VM and wait for SSH ---
cmd_snapshot_rollback() {
    local name="${1:-${PVETEST_SNAPSHOT_NAME:-baseline}}"
    [ -z "$NESTED_VMID" ] && fail "PVETEST_NESTED_VMID is required for snapshot-rollback"
    [ -z "$NESTED_PORT" ] && fail "PVETEST_NESTED_SSH_PORT is required for snapshot-rollback"

    info "Rolling back VM $NESTED_VMID to snapshot '$name'..."
    host_ssh "qm stop $NESTED_VMID 2>/dev/null || true"
    sleep 3

    # Delete all snapshots except the target so rollback can proceed
    # qm listsnapshot format: `-> name   timestamp   description
    local snap
    for snap in $(host_ssh "qm listsnapshot $NESTED_VMID 2>/dev/null" | sed -n 's/^.*-> \([^ ]*\).*/\1/p'); do
        if [ "$snap" != "$name" ] && [ "$snap" != "current" ]; then
            info "Deleting snapshot '$snap'..."
            host_ssh "qm delsnapshot $NESTED_VMID $snap" 2>/dev/null || true
        fi
    done

    host_ssh "qm rollback $NESTED_VMID $name"
    host_ssh "qm start $NESTED_VMID"
    ok "Snapshot '$name' rolled back, VM starting"

    # Wait for VM to be running
    info "Waiting for VM $NESTED_VMID to be running..."
    local i
    for i in $(seq 1 60); do
        host_ssh "qm status $NESTED_VMID 2>/dev/null | grep -q running" 2>/dev/null && break
        sleep 1
    done
    host_ssh "qm status $NESTED_VMID 2>/dev/null | grep -q running" 2>/dev/null \
        || fail "VM $NESTED_VMID not running after 60s"
    ok "VM $NESTED_VMID is running"

    # Wait for nested VM SSH
    info "Waiting for nested VM SSH ($HOST:$NESTED_PORT)..."
    for i in $(seq 1 60); do
        nested_ssh "true" 2>/dev/null && break
        [ $((i % 10)) -eq 0 ] && info "  still waiting... $((i * 2))s"
        sleep 2
    done
    nested_ssh "true" 2>/dev/null || fail "Nested VM SSH not ready after 120s"
    ok "Nested VM SSH is ready"
}

# --- snapshot-create: create a snapshot of the nested VM ---
cmd_snapshot_create() {
    local name="${1:-${PVETEST_SNAPSHOT_NAME:-baseline}}"
    [ -z "$NESTED_VMID" ] && fail "PVETEST_NESTED_VMID is required for snapshot-create"

    info "Creating snapshot '$name' for VM $NESTED_VMID..."
    host_ssh "qm shutdown $NESTED_VMID --timeout 30" 2>/dev/null || true

    # Wait for VM to stop
    local i
    for i in $(seq 1 30); do
        host_ssh "qm status $NESTED_VMID 2>/dev/null | grep -q stopped" 2>/dev/null && break
        sleep 1
    done
    if ! host_ssh "qm status $NESTED_VMID 2>/dev/null | grep -q stopped" 2>/dev/null; then
        info "Graceful shutdown timed out, forcing stop..."
        host_ssh "qm stop $NESTED_VMID" 2>/dev/null || true
        sleep 2
    fi

    host_ssh "qm snapshot $NESTED_VMID $name --description 'pvetest snapshot'"
    host_ssh "qm start $NESTED_VMID"
    ok "Snapshot '$name' created for VM $NESTED_VMID"
}

# --- install-test: full deployer install test with snapshot rollback ---
cmd_install_test() {
    local sha="${1:?Usage: pvetest install-test <sha> <repo-url>}"
    local repo="${2:?Usage: pvetest install-test <sha> <repo-url>}"

    local deployer_vmid="${PVETEST_DEPLOYER_VMID:-300}"
    local deployer_bridge="${PVETEST_DEPLOYER_BRIDGE:-vmbr1}"
    local deployer_ip="${PVETEST_DEPLOYER_STATIC_IP:-10.0.0.100/24}"
    local deployer_gw="${PVETEST_DEPLOYER_GATEWAY:-10.0.0.1}"
    local deployer_ip_bare="${deployer_ip%/*}"
    local owner="${PVETEST_OWNER:-modbus2mqtt}"
    local oci_owner="${PVETEST_OCI_OWNER:-modbus2mqtt}"
    local deployer_url_flag=""
    if [ -n "$DEPLOYER_PORT" ]; then
        deployer_url_flag="--deployer-url http://${HOST}:${DEPLOYER_PORT}"
    fi

    info "=== Install Test ==="

    # 1. Rollback nested VM
    cmd_snapshot_rollback

    # 2. Checkout + build on test-worker
    cmd_checkout "$sha" "$repo"
    info "Installing dependencies and building..."
    cmd_exec pnpm install --frozen-lockfile
    cmd_exec pnpm run build

    # 3. Create install bundle on test-worker and transfer to nested VM
    info "Creating install bundle on test-worker..."
    cmd_exec "tar -czf /tmp/install-bundle.tar.gz install-oci-lxc-deployer.sh json/shared/scripts"

    info "Transferring install bundle to nested VM..."
    # test-worker -> runner -> nested VM (two hops)
    mkdir -p /tmp/pvetest
    remote_scp "$WORKER_USER@$WORKER_HOST:$WORKSPACE/tmp/install-bundle.tar.gz" /tmp/pvetest/ 2>/dev/null \
        || remote_scp "$WORKER_USER@$WORKER_HOST:/tmp/install-bundle.tar.gz" /tmp/pvetest/
    nested_scp_to /tmp/pvetest/install-bundle.tar.gz /tmp/
    nested_ssh "mkdir -p /tmp/oci-lxc-deployer && tar -xzf /tmp/install-bundle.tar.gz -C /tmp/oci-lxc-deployer"
    ok "Install bundle transferred to nested VM"

    # 4. Run install script on nested VM
    info "Running install script on nested VM..."
    nested_ssh "chmod +x /tmp/oci-lxc-deployer/install-oci-lxc-deployer.sh && \
        OWNER=$owner OCI_OWNER=$oci_owner LOCAL_SCRIPT_PATH=/tmp/oci-lxc-deployer \
        /tmp/oci-lxc-deployer/install-oci-lxc-deployer.sh \
        --vm-id $deployer_vmid \
        --bridge $deployer_bridge \
        --static-ip $deployer_ip \
        --gateway $deployer_gw \
        $deployer_url_flag"
    ok "Install script completed"

    # 5. Verify deployer API inside nested VM
    info "Verifying deployer API at $deployer_ip_bare:3000..."
    nested_ssh bash <<VSCRIPT
set -e
for i in \$(seq 1 30); do
    if curl -sf --connect-timeout 1 "http://$deployer_ip_bare:3000/" 2>/dev/null | grep -q "doctype"; then
        exit 0
    fi
    sleep 1
done
echo "Deployer API not ready after 30s" >&2
exit 1
VSCRIPT
    ok "Deployer API is healthy"

    # 6. Build and deploy local package
    info "Creating local package on test-worker..."
    cmd_exec "pnpm pack --pack-destination /tmp"

    info "Deploying package to deployer container..."
    # Fetch tarball from test-worker
    local tarball_name
    tarball_name=$(remote_ssh "ls -1 /tmp/oci-lxc-deployer-*.tgz 2>/dev/null | head -1 | xargs basename")
    [ -z "$tarball_name" ] && fail "No package tarball found on test-worker"
    remote_scp "$WORKER_USER@$WORKER_HOST:/tmp/$tarball_name" /tmp/pvetest/

    # Push to nested VM, then into deployer container
    nested_scp_to "/tmp/pvetest/$tarball_name" /tmp/
    nested_ssh "pct push $deployer_vmid /tmp/$tarball_name /tmp/$tarball_name"

    # Install package in deployer container
    nested_ssh "pct exec $deployer_vmid -- sh -c '
        cd /tmp && \
        rm -rf package && \
        tar -xzf $tarball_name && \
        cd package && \
        npm install --omit=dev --no-audit --no-fund --ignore-scripts 2>/dev/null && \
        rm -rf /usr/local/lib/node_modules/oci-lxc-deployer && \
        mkdir -p /usr/local/lib/node_modules && \
        mv /tmp/package /usr/local/lib/node_modules/oci-lxc-deployer && \
        ln -sf /usr/local/lib/node_modules/oci-lxc-deployer/backend/dist/oci-lxc-deployer.mjs /usr/local/bin/oci-lxc-deployer
    '"
    ok "Package installed in deployer container"

    # Restart and verify
    info "Restarting deployer container..."
    nested_ssh "pct stop $deployer_vmid && sleep 1 && pct start $deployer_vmid"
    sleep 2
    nested_ssh "pct exec $deployer_vmid -- sh -c 'ip link set lo up; ip link set eth0 up; ip addr add $deployer_ip dev eth0 2>/dev/null; ip route add default via $deployer_gw 2>/dev/null' || true"

    info "Verifying API after package update..."
    nested_ssh bash <<VSCRIPT2
set -e
for i in \$(seq 1 20); do
    if curl -sf --connect-timeout 1 "http://$deployer_ip_bare:3000/" 2>/dev/null | grep -q "doctype"; then
        exit 0
    fi
    sleep 1
done
echo "API not ready after restart" >&2
exit 1
VSCRIPT2
    ok "Deployer API healthy after package update"

    # Cleanup
    rm -rf /tmp/pvetest
    ok "=== Install test passed ==="
}

# --- check: validate environment and SSH connectivity ---
cmd_check() {
    local errors=0

    # --- Phase 1: Runner Environment ---
    info "=== Runner Environment ==="
    local vars=(
        "PVETEST_HOST:$HOST"
        "PVETEST_WORKER_HOST:$WORKER_HOST"
        "PVETEST_WORKER_PORT:$PORT"
        "PVETEST_WORKER_USER:$WORKER_USER"
        "PVETEST_WOL_MAC:${WOL_MAC:-(not set)}"
        "PVETEST_WOL_INTERFACE:${WOL_IFACE:-(not set)}"
        "PVETEST_DEPLOYER_PORT:${DEPLOYER_PORT:-(not set)}"
        "PVETEST_WORKSPACE:$WORKSPACE"
        "PVETEST_WOL_TIMEOUT:$WOL_TIMEOUT"
        "PVETEST_SSH_TIMEOUT:$SSH_TIMEOUT"
        "PVETEST_API_TIMEOUT:$API_TIMEOUT"
        "PVETEST_NESTED_SSH_PORT:${NESTED_PORT:-(not set)}"
        "PVETEST_NESTED_VMID:${NESTED_VMID:-(not set)}"
        "PVETEST_SNAPSHOT_NAME:${PVETEST_SNAPSHOT_NAME:-(not set)}"
        "PVETEST_DEPLOYER_VMID:${PVETEST_DEPLOYER_VMID:-(not set)}"
        "PVETEST_DEPLOYER_BRIDGE:${PVETEST_DEPLOYER_BRIDGE:-(not set)}"
        "PVETEST_DEPLOYER_STATIC_IP:${PVETEST_DEPLOYER_STATIC_IP:-(not set)}"
        "PVETEST_DEPLOYER_GATEWAY:${PVETEST_DEPLOYER_GATEWAY:-(not set)}"
        "PVETEST_OWNER:${PVETEST_OWNER:-(not set)}"
        "PVETEST_OCI_OWNER:${PVETEST_OCI_OWNER:-(not set)}"
    )
    for entry in "${vars[@]}"; do
        local name="${entry%%:*}"
        local value="${entry#*:}"
        printf "  %-28s = %s\n" "$name" "$value"
    done

    # Runner-specific env vars (from entrypoint / LXC environment)
    printf "  %-28s = %s\n" "REPO_URL" "${REPO_URL:-(not set)}"
    printf "  %-28s = %s\n" "RUNNER_NAME" "${RUNNER_NAME:-(not set)}"
    printf "  %-28s = %s\n" "LABELS" "${LABELS:-(not set)}"
    if [ -n "${ACCESS_TOKEN:-}" ]; then
        printf "  %-28s = %s\n" "ACCESS_TOKEN" "***masked***"
    else
        printf "  %-28s = %s\n" "ACCESS_TOKEN" "(not set)"
    fi
    if [ -n "${SSH_PRIVATE_KEY:-}" ] || [ -f /root/.ssh/id_ed25519 ]; then
        printf "  %-28s = %s\n" "SSH_PRIVATE_KEY" "present"
    else
        printf "  %-28s = %s\n" "SSH_PRIVATE_KEY" "(not set)"
    fi
    echo ""

    ok "Environment check complete"
}

# --- Main ---
case "${1:-help}" in
    wake)              cmd_wake ;;
    check)             cmd_check ;;
    checkout)          shift; cmd_checkout "$@" ;;
    exec)              shift; cmd_exec "$@" ;;
    fetch)             shift; cmd_fetch "$@" ;;
    host-exec)         shift; cmd_host_exec "$@" ;;
    nested-exec)       shift; cmd_nested_exec "$@" ;;
    snapshot-rollback) shift; cmd_snapshot_rollback "$@" ;;
    snapshot-create)   shift; cmd_snapshot_create "$@" ;;
    install-test)      shift; cmd_install_test "$@" ;;
    help|*)
        cat <<'USAGE'
Usage: pvetest <command> [arguments]

Commands:
  wake                          Wake PVE host via WOL, wait for test-worker SSH
  check                         Validate environment variables and SSH connectivity
  checkout <sha> <repo-url>     Clone/fetch/checkout on test-worker
  exec <command...>             Run command in workspace on test-worker
  fetch <remote-path> <local>   Copy files from test-worker workspace
  host-exec <command...>        Run command on PVE host (SSH port 22)
  nested-exec <command...>      Run command on nested VM (via port forwarding)
  snapshot-rollback [name]      Rollback nested VM to snapshot (default: baseline)
  snapshot-create [name]        Create snapshot of nested VM
  install-test <sha> <repo-url> Full install test: rollback, build, install, verify

Environment variables:
  PVETEST_HOST              Hostname/IP of PVE backend (required)
  PVETEST_WORKER_HOST       Hostname of test-worker (default: PVETEST_HOST)
  PVETEST_WORKER_PORT       SSH port for test-worker (default: 22)
  PVETEST_WORKER_USER       SSH user (default: root)
  PVETEST_WOL_MAC           MAC address for Wake-on-LAN
  PVETEST_DEPLOYER_PORT     Deployer API port for health check
  PVETEST_WORKSPACE         Remote workspace path (default: /root/workspace)
  PVETEST_NESTED_SSH_PORT   SSH port for nested VM (for install-test)
  PVETEST_NESTED_VMID       VM ID of nested VM (for install-test/snapshot)
USAGE
        [ "${1:-}" = "help" ] && exit 0 || exit 1
        ;;
esac
